// NanoCore Kernel
// Ultra-efficient kernel architecture

import { Hardware } from "./hardware"
import { Memory } from "./memory"
import { Thread } from "./thread"
import { Sync } from "./sync"

// Kernel configuration (compile-time)
const CONFIG {
    // Hardware settings
    MAX_CPUS: u8 = 32
    MAX_DEVICES: u16 = 256
    
    // Memory settings
    PAGE_SIZE: u32 = 4096
    MAX_MEMORY: u64 = 1 << 48  // 256TB
    
    // Process settings
    MAX_THREADS: u16 = 1024
    MAX_PRIORITY: u8 = 32
    
    // System settings
    TICK_RATE: u32 = 1000
    MAX_SYSCALLS: u16 = 128
}

// Core kernel state
struct Kernel {
    // Hardware management
    hw: Hardware
    
    // Memory management (zero-copy)
    mem: Memory
    
    // Thread management
    threads: StaticVec<Thread, CONFIG.MAX_THREADS>
    current: [u16; CONFIG.MAX_CPUS]
    
    // Synchronization
    sync: Sync
}

impl Kernel {
    // Initialize kernel
    fn init() -> Result<Kernel, Error> {
        // Initialize hardware first
        let hw = Hardware::init()?
        
        // Initialize memory with hardware map
        let mem = Memory::init(hw.get_memory_map())?
        
        // Initialize thread management
        let threads = StaticVec::new()
        let current = [0; CONFIG.MAX_CPUS]
        
        // Initialize synchronization
        let sync = Sync::init()?
        
        Ok(Kernel {
            hw,
            mem,
            threads,
            current,
            sync
        })
    }
    
    // Fast path system call handler
    #[inline(always)]
    fn syscall(&mut self, number: u16, args: &[u64]) -> Result<u64, Error> {
        // Validate syscall number at compile time
        if number >= CONFIG.MAX_SYSCALLS {
            return Err(Error::InvalidSyscall)
        }
        
        // Direct dispatch without context switch
        match number {
            SYS_MEMORY -> self.handle_memory(args),
            SYS_THREAD -> self.handle_thread(args),
            SYS_DEVICE -> self.handle_device(args),
            _ -> self.handle_other(number, args)
        }
    }
    
    // Memory operations (zero-copy)
    #[inline(always)]
    fn handle_memory(&mut self, args: &[u64]) -> Result<u64, Error> {
        match args[0] {
            MEM_ALLOC -> self.mem.alloc_fast(args[1]),
            MEM_FREE -> self.mem.free_fast(args[1]),
            _ -> Err(Error::InvalidMemoryOp)
        }
    }
    
    // Thread operations (minimal switching)
    #[inline(always)]
    fn handle_thread(&mut self, args: &[u64]) -> Result<u64, Error> {
        match args[0] {
            THREAD_CREATE -> self.create_thread_fast(args[1], args[2]),
            THREAD_EXIT -> self.exit_thread_fast(args[1]),
            _ -> Err(Error::InvalidThreadOp)
        }
    }
    
    // Device operations (direct access)
    #[inline(always)]
    fn handle_device(&mut self, args: &[u64]) -> Result<u64, Error> {
        // Direct hardware access through Linux firmware layer
        self.hw.access_device(args[0], &args[1..])
    }
    
    // Interrupt handler (minimal overhead)
    #[inline(always)]
    fn handle_interrupt(&mut self, irq: u32) -> Result<(), Error> {
        match irq {
            IRQ_TIMER -> self.handle_timer_fast(),
            IRQ_DEVICE -> self.hw.handle_device_irq(irq),
            _ -> self.hw.handle_other_irq(irq)
        }
    }
    
    // Fast thread creation
    #[inline(always)]
    fn create_thread_fast(&mut self, entry: u64, priority: u8) -> Result<u64, Error> {
        if priority >= CONFIG.MAX_PRIORITY {
            return Err(Error::InvalidPriority)
        }
        
        // Use pre-allocated thread slot
        let thread = Thread::new(entry, priority)?
        let id = self.threads.push(thread)?
        
        Ok(id as u64)
    }
    
    // Fast thread exit
    #[inline(always)]
    fn exit_thread_fast(&mut self, id: u64) -> Result<u64, Error> {
        // Direct thread cleanup without scheduling
        self.threads.remove(id as usize)?
        Ok(0)
    }
    
    // Fast timer handling
    #[inline(always)]
    fn handle_timer_fast(&mut self) -> Result<(), Error> {
        // Minimal scheduling overhead
        let cpu = self.hw.current_cpu()
        let next = self.find_next_thread(cpu)
        
        if next != self.current[cpu] {
            self.switch_to(cpu, next)?
        }
        
        Ok(())
    }
    
    // Find next thread (optimized search)
    #[inline(always)]
    fn find_next_thread(&self, cpu: usize) -> u16 {
        // Priority-based selection
        let mut best_priority = 0
        let mut best_thread = self.current[cpu]
        
        for (id, thread) in self.threads.iter().enumerate() {
            if thread.priority > best_priority && thread.state.is_runnable() {
                best_priority = thread.priority
                best_thread = id as u16
            }
        }
        
        best_thread
    }
    
    // Fast context switch
    #[inline(always)]
    fn switch_to(&mut self, cpu: usize, thread: u16) -> Result<(), Error> {
        // Direct register swap
        unsafe {
            let old = &self.threads[self.current[cpu] as usize]
            let new = &self.threads[thread as usize]
            
            swap_context(&old.context, &new.context)
        }
        
        self.current[cpu] = thread
        Ok(())
    }
}

// Fast context swap
#[inline(always)]
unsafe fn swap_context(old: &Context, new: &Context) {
    asm!(
        "mov [{0}], rsp",
        "mov [{0} + 8], rbp",
        "mov rsp, [{1}]",
        "mov rbp, [{1} + 8]",
        "jmp [{1} + 16]",
        in(reg) old as *const Context,
        in(reg) new as *const Context
    )
}
